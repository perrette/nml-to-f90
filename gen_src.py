""" python program to generate fortran source code capable of read/write, set/get parameters from a list of types
"""
from collections import OrderedDict as odict
from namelist import Namelist, read_namelist_file

#
# TO BE UPDATED BY THE USER, IF NEEDED
#
# module name where parameter types are defined
params_mod="params" 

# new module name to be generated with all io routines
io_mod="ioparams"

# returns derived type name based on namelist group name
# it was taken to match nml's test program
def derived_type_name(group):
    return "pars_"+group.lower()

#
# BELOW CODE IS FINE
#

def _get_vtype(v, freecharlen=False):
    """ return fortran type for a particular namelist variable
    """
    vtype_short = ""
    if type(v) is int:
        vtype = "integer"
    elif type(v) is bool:
        vtype = "logical"
    elif type(v) is float:
        vtype = "real(dp)"
        vtype_short = "double"
    elif type(v) is str:
        vtype = "character(len={})".format("*" if freecharlen else len(v))
        vtype_short = "char"
    elif type(v) is list:
        vtype0, vtype0_short = _get_vtype(v[0])
        vtype = "{vtype}, dimension({len})".format(vtype=vtype0, len=len(v)) 
        vtype_short = vtype0_short+'_arr'
    else:
        print "Error with: ", v
        print "Unexpected type: ", type(v)
        raise TypeError("Unknown type")
    vtype_short = vtype_short or vtype
    return vtype, vtype_short

template_full = """
module {io_module_name}
    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! Automatically generated module
    ! 
    ! Contains read / write subroutines for all derived types imported below.
    ! As well as setter / getter access by field name
    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    use {params_module_name}, only: {types}

    implicit none

    private
    public :: read_nml, write_nml, set_param, get_param

    integer, parameter :: dp = kind(0.d0)

    interface read_nml
        {read_nml_proc}
    end interface

    interface write_nml
        {write_nml_proc}
    end interface

    interface set_param
        {set_param_proc}
    end interface

    interface get_param
        {get_param_proc}
    end interface

contains

    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! IO routines
    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    {io_routines}

    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! SET / GET routines
    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    {setget_routines}

end module {io_module_name}
"""

template_read = """
subroutine read_nml_{group} (iounit, params)
    !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! Read the {group} block in a namelist file and assign to type
    !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    integer, intent(in) :: iounit
    type({type_name}), intent(inout) :: params

    {variable_definitions}

    namelist / {group} / {list_of_variables}

    ! initialize variables
    {list_of_init}

    ! read all
    read(unit=iounit, nml={group}) 

    ! assign back to type
    {list_of_assign}
end subroutine
"""

template_write = """
subroutine write_nml_{group} (iounit, params)
    !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! Read the {group} block in a namelist file and assign to type
    !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    integer, intent(in) :: iounit
    type({type_name}), intent(inout) :: params

    {variable_definitions}

    namelist / {group} / {list_of_variables}

    ! initialize variables
    {list_of_init}

    ! write_all
    write(unit=iounit, nml={group}) 
end subroutine
"""

def get_format_io(params, params_mod, io_mod):
    """ Create I/O source code from a namelist template

    params : dict of dict (params[group][param_name])
    params_mod : str
        module name where parameter types are defined
    io_mod: str
        new module name generated by this function
    """
    groups = params.keys()
    types = [derived_type_name(g) for g in groups]

    io_routines = []
    read_nml_interface = []
    write_nml_interface = []

    # Namelist I/O for whole groups
    for G, t in zip(groups, types):

        # fill-in...
        variable_definitions = []
        list_of_variables = []
        list_of_init = []
        list_of_assign = []

        g = G.lower()

        for K in params[G]:
            k = K.lower()
            vtype, _ = _get_vtype(params[G][K])
            variable_definitions.append("{vtype} :: {name}".format(vtype=vtype, name=k))
            list_of_variables.append(k)
            list_of_init.append("{name} = params%{name}".format(name=k, group=g))
            list_of_assign.append("params%{name} = {name}".format(name=k, group=g))

        fmt = dict(
            group=g,
            type_name = t,
            variable_definitions="\n    ".join(variable_definitions),
            list_of_variables = ", ".join(list_of_variables),
            list_of_init = "\n    ".join(list_of_init),
            list_of_assign = "\n    ".join(list_of_assign),
        )

        io_routines.append( template_read.format(**fmt) )
        io_routines.append( template_write.format(**fmt) )

        read_nml_interface.append("module procedure :: read_nml_{g}".format(g=g)) 
        write_nml_interface.append("module procedure :: write_nml_{g}".format(g=g)) 

    # source_code = template_full.format(types = ", ".join(types), 
    fmt = dict(types = ", ".join(types), 
               io_routines = "\n\n".join(io_routines),
               io_module_name = io_mod,
               params_module_name = params_mod,
               read_nml_proc = "\n        ".join(read_nml_interface),
               write_nml_proc = "\n        ".join(write_nml_interface),
               )

    return fmt


template_set = """
subroutine set_param_{group}_{vtype_name} (params, name, value)
    !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! Set one field of the {group} type
    !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    type({type_name}), intent(inout) :: params
    character(len=*), intent(in) :: name
    {vtype}, intent(in) :: value

    select case (name) 
        {list_set_cases}
        case default
        write(*,*) "ERROR set_param for {group}: unknown type member: {vtype} :: ",trim(name)
            stop
    end select
end subroutine
"""

template_get = """
subroutine get_param_{group}_{vtype_name} (params, name, value)
    !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! Set one field of the {group} type
    !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    type({type_name}), intent(inout) :: params
    character(len=*), intent(in) :: name
    {vtype}, intent(out) :: value

    select case (name) 
        {list_get_cases}
        case default
            write(*,*) "ERROR get_param for {group}: unknown type member {vtype} :: ",trim(name)
            stop
    end select
end subroutine
"""

template_get_cases = """
case ('{vname}')
    value = params%{vname}
"""
template_set_cases = """
case ('{vname}')
    params%{vname} = value
"""

def get_format_setget(params, params_mod, io_mod):
    """ Create I/O source code from a namelist template

    params : dict of dict (params[group][param_name])
    params_mod : str
        module name where parameter types are defined
    io_mod: str
        new module name generated by this function
    """
    groups = params.keys()
    types = [derived_type_name(g) for g in groups]

    get_param_interface = []
    set_param_interface = []

    setget_routines = []

    # loop over derived types
    for G, t in zip(groups, types):

        g = G.lower()

        # determine the list of all variable types present in this derived type
        # build a dict of [(vtype1: [p11, p12, ...]), ...]
        # and of the vtpyes shortnames to name routines
        vtypes = {}
        vtypes_short = {}
        for K in params[G].keys():
            k = K.lower()
            vtype, vtype_short = _get_vtype(params[G][K], freecharlen=True)
            if vtype not in vtypes:
                vtypes[vtype] = []
            vtypes[vtype].append(k)
            vtypes_short[vtype] = vtype_short

        # loop over all types
        for vtype in vtypes:
            vtype_short = vtypes_short[vtype]
            # print 'group:',g, 'vtype', vtype
            list_get_cases = []
            list_set_cases = []
            for k in vtypes[vtype]:
                list_get_cases.append( template_get_cases.format(vname=k) )
                list_set_cases.append( template_set_cases.format(vname=k) )

            # the subroutines
            setget_routines.append(
                template_get.format(
                    vtype=vtype,
                    vtype_name=vtype_short,
                    group=g, # namelist-like group (shorter)
                    type_name= derived_type_name(g), # actual derived type
                    list_get_cases= "\n".join(list_get_cases),
                )
            )

            setget_routines.append(
                template_set.format(
                    vtype=vtype,
                    vtype_name=vtype_short,
                    group=g, # namelist-like group (shorter)
                    type_name= derived_type_name(g), # actual derived type
                    list_set_cases= "\n".join(list_set_cases),
                )
            )

            # prepare interface of all subroutines
            get_param_interface.append(
                "module procedure :: get_param_{group}_{vtype_name}".format(vtype_name=vtypes_short[vtype], group=g)
            )
            set_param_interface.append(
                "module procedure :: set_param_{group}_{vtype_name}".format(vtype_name=vtypes_short[vtype], group=g)
            )


    fmt = dict(
        types = ", ".join(types), 
        set_param_proc = "\n        ".join(set_param_interface),
        get_param_proc = "\n        ".join(get_param_interface),
        setget_routines = "\n\n".join(setget_routines),
        io_module_name = io_mod,
        params_module_name = params_mod,
    )

    return fmt

def make_source(params, params_mod, io_mod):
    """ Make source code with I/O and getter / setter
    """
    fmt_io = get_format_io(params, params_mod, io_mod)
    fmt = {}
    fmt = get_format_setget(params, params_mod, io_mod)
    fmt.update(fmt_io)
    return template_full.format(**fmt)

if __name__ == "__main__":
    # when the types are to be output in a dummy, temporary 
    # namelist, they are grouped under this name (this can 
    # stay liek this without any impact, so leave it)
    dummygroup="ALLPARAMS"

    # read namelist template
    nml = read_namelist_file("namelist.template.nml")
    if len(nml.groups.keys()) == 1 and dummygroup in nml.groups.keys():
        print "Parse from a mixed-up, grouped dummy namelist"
        params = odict()
        for k in nml.groups[dummygroup].keys():
            g, nm = k.split("%")
            if g not in params:
                params[g] = odict()
            params[g][nm] = nml.groups[dummygroup][k]
    else:
        print "Parse from an example namelist (not a dummy one)"
        print nml.groups.keys()
        params = nml.groups

    code = make_source(params, params_mod, io_mod)
    with open(io_mod+'.f90', 'w') as f:
        f.write(code)
